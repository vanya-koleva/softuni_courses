# Django Models Relations

## Database Normalization

-   Normalizations - rules for database design.

-   Data normalization **breaks large tables into smaller ones**, making the data more organized, **improving maintainability** and **avoiding repetition** of data.

-   Example: Imagine an online store - rather than storing customer name, address, and order details in a single table, we split them into three tables, avoiding redundant records.

-   Database schema design

    -   Creating keys and relationships between tables.

-   Minimizing data redundancy

    -   Splitting tables helps reduce data duplication.

    -   Example: If we have a book and multiple copies, the copies should be stored in a separate table and linked to the original book.

-   Ensuring data integrity & eliminating data anomalies

    -   Helps ensure that **updates** and **deletions** are consistent across the database.

    -   By using **constraints**, we can modify a value in one table, and it will automatically reflect in all related tables.

-   Efficiency and maintainability
    -   Smaller tables allow for **faster queries and updates**, improving performance and maintainability.

### Normal Forms

-   Every subsequent NF builds on the previous ones, meaning it adheres to all of the conditions of the previous forms.

#### First Normal Form (1NF)

-   No repeating records or fields.
-   Should have (Primary Key) **PK**.
-   **Atomic data**.
-   Each column contains values of a **single type**.

#### Second Normal Form (2NF)

-   Has **no partial dependencies**: ensures that all non-key attributes are fully dependent on the **entire PK**.

    -   A partial dependency occurs when an attribute (column) depends only on a part of a composite primary key rather than the entire key.

#### Third Normal Form (3NF)

-   **No transitive dependencies** where a non-key column depends on another non-key column instead of directly depending on the Primary Key (PK).

-   Example: A table storing Employee ID, Employee Name, City, and Address has a transitive dependency if Address depends on City rather than directly on Employee ID.

-   To satisfy 3NF, we split the data into three tables—Employees, Cities, and Addresses. The relationships do not necessarily have to be based on a Primary Key (PK); for instance, linking via city_id ensures that an employee is associated with a city rather than a specific address.

#### Boyce-Codd Normal Form (BCNF)

-   A stricter version of 3NF.
-   Ensures that all functional dependencies are based **only on the PK**.

\*Pattern - 1NF and 3NF say what should be done, 2NF and BCNF say how it should be done.

#### Fourth Normal Form (4NF)

-   **No multivalued dependencies (MVDs).**

-   A multivalued dependency occurs when a single key (e.g., "Course") is linked to multiple independent sets of values.

-   Example: If a table has columns Course, Lecturer, and Book, it can be split into two separate tables: Course – Lecturer, Course – Book

#### Fifth Normal Form (5NF) – Project-Join Normal Form (PJ/NF)

-   Ensures that no data redundancy exists due to **join dependencies**.

-   In simple terms, it eliminates the need to go through tables with data we don't need (except for junction tables) in order to reach the table we need.

## Relationships in Django Models

-   `related_name` - An optional parameter that defines how we will access the model from the parent's side.

    -   Generated by default by appending `_set` to the **lowercase** name of the child's model.

-   **Lazy Relationships** - deferring the evaluation of a related model until it is actually needed.

    -   Prevents circular imports (e.g., when two models reference each other).

    -   Allows defining relationships before the related model exists.

    -   Using **strings** to define model relationships without direct imports.

### Types of Relationships

#### Many-To-One (One-To-Many)

-   **Foreign key** - placed in the child model (the "many" side).

    -   The **parent** model has **one** record that can be linked to multiple records in the child model.
    -   The **child** model has a ForeignKey that points to the parent, meaning **many** child records can be associated with a single parent record.
    -   One Author (parent) → Many Books (children)

-   Requires **two** positional arguments:
    -   the parent **class**
    -   the **on_delete** option

```python
class Author(models.Model):  # Parent model
    name = models.CharField(max_length=100)

class Book(models.Model):  # Child model (many)
    title = models.CharField(max_length=200)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

author = Author.objects.get(id=1)
books = author.book_set.all()  # Default reverse relation
```

#### Many-to-Many Relationship

-   **ManyToManyField**

    -   Requires **one** positional argument:
        -   The **class** to which the model is related
    -   It is placed only in **one** of the models, it doesn't matter which one.

-   Django automatically creates a join (or junction) table.

-   `through` option - Lets us specify the junstion table.

    -   Allows for adding extra fields.

    -   If we already have a junction table, we are going to get a ValueError.
        -   For reference: https://docs.djangoproject.com/en/5.0/howto/writing-migrations/#changing-a-manytomanyfield-to-use-a-through-model

```python
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=200)
    authors = models.ManyToManyField(Author, through='AuthorBook')

class AuthorBook(models.Model):
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    book = models.ForeignKey(Book, on_delete=models.CASCADE)
    publication_date = models.DateField()
```

#### One-to-One Relationship

-   **OneToOneField**

    -   ForeignKey with `unique=True`

    -   Requires:
        -   the **class**
        -   the **on_delete** option

-   Usually used on the PK, when that object "extends" another object in some way.

-   Example: You may have a User model, and each user has exactly one Profile.

#### Self-referential Foreign Key

-   When creating a relation with instances of the same model.

-   Used to establish hierarchical or recursive relationships within a single model.

-   Example: A company has employees, and each employee may have a manager (who is also an employee).

```python
class Employee(models.Model):
    name = models.CharField(max_length=100)
    supervisor = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True)
```

